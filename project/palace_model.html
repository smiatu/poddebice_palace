<!DOCTYPE html>
<html lang="en-GB">
	<head>
		<meta charset="utf-8">
		<title>PoddÄ™bice palace model</title>
		<link rel="stylesheet" href="styles.css">
	</head>
	<body>
		<script src="three.js"></script>
		<script src="PointerLockControls.js"></script>

		<div id="blocker">

			<div id="instructions">
				<span style="font-size:40px">Click to play</span>
				<br />
				(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
			</div>

		</div>

		<script>

			let camera, scene, renderer;
			let geometry, material, mesh;
			let controls,time = Date.now();

			let objects = [];

			let ray;


			const instructions = document.getElementById( 'instructions' );

			let havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

			if ( havePointerLock ) {
				let element = document.body;

				const pointerlockchange = function ( event ) {
					if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
						controls.enabled = true;
					} else {
						controls.enabled = false;
						instructions.style.display = '';
					}
				}

				let pointerlockerror = function ( event ) {
					instructions.style.display = '';
				}

				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockchange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

				document.addEventListener( 'pointerlockerror', pointerlockerror, false );
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

				instructions.addEventListener( 'click', function ( event ) {

					instructions.style.display = 'none';

					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

					if ( /Firefox/i.test( navigator.userAgent ) ) {

						let fullscreenchange = function ( event ) {

							if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

								document.removeEventListener( 'fullscreenchange', fullscreenchange );
								document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

								element.requestPointerLock();
							}

						}

						document.addEventListener( 'fullscreenchange', fullscreenchange, false );
						document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

						element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

						element.requestFullscreen();

					} else {

						element.requestPointerLock();

					}

				}, false );

			} else {

				instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

			}

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );

				scene = new THREE.Scene();

				let light = new THREE.DirectionalLight( 0xffffff, 1.5 );
				light.position.set( 1, 1, 1 );
				scene.add( light );

				light = new THREE.DirectionalLight( 0xffffff, 0.75 );
				light.position.set( -1, - 0.5, -1 );
				scene.add( light );

				controls = new THREE.PointerLockControls( camera );
				scene.add( controls.getObject() );

				ray = new THREE.Raycaster();
				ray.ray.direction.set( 0, -1, 0 );

				// floor

				const floorGeometry = new THREE.PlaneGeometry( 2000, 2000 );
				floorGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(- Math.PI / 2))
				//todo do poprawy na jakas trawe czy cos
				const floorMaterial = new THREE.MeshLambertMaterial({
					color: 0x159947,
					side: THREE.DoubleSide
				})
				const floor = new THREE.Mesh(floorGeometry, floorMaterial);
				scene.add(floor);

				// globals

				const wallsMaterial = new THREE.MeshPhongMaterial({
					color: 0xf5f5dc
				})
				const rooftopMaterial = new THREE.MeshPhongMaterial({
					color: 0x696F71
				});

				const PrismGeometry = function ( vertices, height ) {
					let Shape = new THREE.Shape();
					( function f( ctx ) {
						ctx.moveTo( vertices[0].x, vertices[0].y );
						for (let i=1; i < vertices.length; i++) {
							ctx.lineTo( vertices[i].x, vertices[i].y );
						}
						ctx.lineTo( vertices[0].x, vertices[0].y );
					} )( Shape );

					let settings = { };
					settings.amount = height;
					settings.bevelEnabled = false;
					THREE.ExtrudeGeometry.call( this, Shape, settings );
				};

				//prism-alike objects

				PrismGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

				let A = new THREE.Vector2( 0, 0 );
				let B = new THREE.Vector2( 100, 0 );
				let C = new THREE.Vector2( 0, 30 );
				let height = 30;

				const staircaseTopGeometry = new PrismGeometry( [ A, B, C ], height );
				const staircaseTop = new THREE.Mesh( staircaseTopGeometry, wallsMaterial );
				staircaseTop.position.set(225,120,270);
				scene.add( staircaseTop );

				A = new THREE.Vector2( -75, 0 );
				B = new THREE.Vector2( 75, 0 );
				C = new THREE.Vector2( 0, 60 );
				height = 300;

				const mainBuildingsRooftopGeometry = new PrismGeometry( [ A, B, C ], height );

				const mainBuildingRooftop = new THREE.Mesh(mainBuildingsRooftopGeometry, rooftopMaterial);
				mainBuildingRooftop.position.set(150,150,0);
				scene.add(mainBuildingRooftop);

				const wingRooftop = new THREE.Mesh(mainBuildingsRooftopGeometry, rooftopMaterial);
				wingRooftop.position.set(0,100,-75);
				wingRooftop.rotation.y = Math.PI / 2;
				scene.add(wingRooftop);

				// objects
				const staircaseGeometry = new THREE.BoxGeometry(100, 120, 30);
				const staircase = new THREE.Mesh(staircaseGeometry, wallsMaterial);
				staircase.position.set(275, 60, 285);
				scene.add(staircase);

				const mainBuildingBodyGeometry = new THREE.BoxGeometry(150,150,300);
				const mainBuilding = new THREE.Mesh( mainBuildingBodyGeometry, wallsMaterial );
				mainBuilding.position.set(150,75,150);
				scene.add(mainBuilding);

				const wingBodyGeometry = new THREE.BoxGeometry(300,100,150);
				const wingBody = new THREE.Mesh( wingBodyGeometry, wallsMaterial );
				wingBody.position.set(150,50,-75);
				scene.add(wingBody);

				const chapelBodyGeometry = new THREE.CylinderGeometry(67.5,67.5,75,8);
				const chapel = new THREE.Mesh( chapelBodyGeometry, wallsMaterial );
				chapel.position.set(0,37.5,250);
				scene.add(chapel);

				const chapelRooftopGeometry = new THREE.ConeGeometry(75, 30, 8, 1);
				const chapelRooftop = new THREE.Mesh(chapelRooftopGeometry,rooftopMaterial);
				chapelRooftop.position.set(0, 90, 250);
				scene.add(chapelRooftop);

				const towerBodyGeometry = new THREE.CylinderGeometry(30,30,250,8);
				const tower = new THREE.Mesh( towerBodyGeometry, wallsMaterial );
				tower.position.set(350,125,280);
				scene.add(tower);

				const towerRoofBaseGeometry = new THREE.ConeGeometry(35, 15, 8);
				const towerRoofBase = new THREE.Mesh(towerRoofBaseGeometry, rooftopMaterial);
				towerRoofBase.position.set(350,260,280);
				scene.add(towerRoofBase);

				const towerRoofDrumGeometry = new THREE.CylinderGeometry(20, 20, 10, 8);
				const towerRoofDrum = new THREE.Mesh(towerRoofDrumGeometry, rooftopMaterial);
				towerRoofDrum.position.set(350, 262, 280);
				scene.add(towerRoofDrum);

				const towerRoofDrumTopGeometry = new THREE.ConeGeometry(25, 10, 8);
				const towerRoofDrumTop = new THREE.Mesh(towerRoofDrumTopGeometry, rooftopMaterial);
				towerRoofDrumTop.position.set(350,272,280);
				scene.add(towerRoofDrumTop);

				const towerRoofDomeGeometry = new THREE.TorusGeometry(12, 10, 16, 8);
				const towerRoofDome = new THREE.Mesh(towerRoofDomeGeometry, rooftopMaterial);
				towerRoofDome.rotation.x = Math.PI / 2;
				towerRoofDome.position.set(350, 276, 280);
				scene.add(towerRoofDome);

				const towerRoofLanternBaseGeometry = new THREE.ConeGeometry(15, 10, 8);
				const towerRoofLanternBase = new THREE.Mesh(towerRoofLanternBaseGeometry, rooftopMaterial);
				towerRoofLanternBase.position.set(350, 290, 280);
				scene.add(towerRoofLanternBase);

				const towerRoofLanternGeometry = new THREE.ConeGeometry(4, 30, 8);
				const towerRoofLantern = new THREE.Mesh(towerRoofLanternGeometry, rooftopMaterial);
				towerRoofLantern.position.set(350, 305, 280);
				scene.add(towerRoofLantern);

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xffffff );
				renderer.setSize( window.innerWidth, window.innerHeight );

				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				//

				controls.isOnObject( false );

				ray.ray.origin.copy( controls.getObject().position );
				ray.ray.origin.y -= 10;

				const intersections = ray.intersectObjects( objects );

				if ( intersections.length > 0 ) {
					let distance = intersections[ 0 ].distance;

					if ( distance > 0 && distance < 10 ) {
						controls.isOnObject( true );
					}
				}

				controls.update( Date.now() - time );

				renderer.render( scene, camera );

				time = Date.now();

			}

		</script>
	</body>
</html>
